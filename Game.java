import javax.swing.*;import java.awt.*;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import java.awt.event.MouseEvent;import java.util.LinkedList;import java.util.Random;import java.util.concurrent.TimeUnit;public class Game implements ActionListener {    //Data:    public int currentLevel;    //Benutzerführung:    public JTextArea levelAnzeige;    private boolean gridLines;    /**     * (Aufbau für folgende Level ist identsch)     * Erstellen des Levels (Level 0 = Lobby)     * createLobby (createLevel) -> Konfiguration der Mappfade/Mover Pos/Gegner Position     * + weitere nötige Variable damit das Spiel funktioniert (currentLevel für Spielmechanik,active für die GUI)     */    long starttime;    /**     * Spielmechanik für die Lobby     */    int difficulty = 5; // Schwierigkeit 1-6    public int click = 0;    private int currentClick;    private int currentSteps;    private int dialog;    private boolean active;    private long timestamp;    private KeyManager keyListener;    private Level[] level;    double startSpeed;    int enemySpawn;    private boolean gameOver = false;    /**     * Spiel Klasse die vorgefertigte Level beinhaltet = eigentliche Spielumgebung-> Konfigurierbar     */    //Konfiguration:    // Objekte kann man nicht konfigurieren da das Spiel vorprogrammiert ist!    //Core Objects:    private GamePanel gamePanel;    /**     * Game Klasse benötigt Bildschirm (Panel) und Tastatureingaben (keyListener) um     * das Spiel laufen zu lassen     */    public Game(GamePanel gp, KeyManager pKeyListener) {        gamePanel = gp;        keyListener = pKeyListener;        //DEBUGGING:        levelAnzeige = new JTextArea("levelAnzeige");        levelAnzeige.setFocusable(false);        GUI.addToDebugPane(levelAnzeige);        createLevel();        createLobby();        active = true;    }    /**     * Erstellen des Level Menus (kann in MenuUI miteinbezogen werden)     */    public MenuUI.MenuTab createLevelMenu() {        String[] name = new String[level.length];        name[0] = "Lobby";        for (int i = 1; i < level.length; i++) {            name[i] = Integer.toString(level[i].getLevel());        }        MenuUI.MenuTab lvlMenu = new MenuUI.MenuTab("", name);        return lvlMenu;    }    /**     * Erstellen eines Level     * -> mehrere Level = Level Arrray     * -> benotigte Map- und Gegneranzahl werden im Vorraus angegeben und erstellt,     * damit die Konfiguration einfacher und übersichtlicher ist (ist nicht zwingend nötig!)     */    private void createLevel() {        level = new Level[4];        for (int i = 0; i < level.length; i++) {            level[i] = new Level(gamePanel, i, keyListener, gamePanel.getCamera());        }        // ChaseMe - Jagd der Ermordoung        // ChaseMe - Labyrinth der Wälder        level[2].createLevelObjects(2, 10);        // ChaseMe - Der Beweis        level[3].createLevelObjects(2, 2);    }    public void createLobby() {        level[0].createLevelObjects(1, 0);        Character mover = level[0].getMover();        level[0].setBaseMap("Content/Maps/menu.txt", "Border");        mover.setLocation(100, 100);        setCurrentLevel(0);        starttime = System.currentTimeMillis();    }    public void level0GameMechanic() {        int corner = new Random().nextInt(3);        LinkedList<Runner> enemy = level[0].getEnemyList();        switch (difficulty) {            case 1:                startSpeed = 0.25;                enemySpawn = 1;                break;            case 2:                startSpeed = 0.25;                enemySpawn = 1;                break;            case 3:                startSpeed = 0.5;                enemySpawn = 2;                break;            case 4:                startSpeed = 0.75;                enemySpawn = 2;                break;            case 5:                startSpeed = 1;                enemySpawn = 1;                break;            case 6:                startSpeed = 1;                enemySpawn = 2;                break;        }        if (elapsedTime(timestamp) > 1.5 && level[0].getMover().isOnThisTile(5, 5, 3)) {            switch (corner) {                case 0:                    for (int i = 0; i < enemySpawn; i++) {                        level[0].addNewEnemyOnTile(1, 1, startSpeed);                    }                    break;                case 1:                    for (int i = 0; i < enemySpawn; i++) {                        level[0].addNewEnemyOnTile(8, 1, startSpeed);                    }                    break;                case 2:                    for (int i = 0; i < enemySpawn; i++) {                        level[0].addNewEnemyOnTile(1, 8, startSpeed);                    }                    break;                case 3:                    for (int i = 0; i < enemySpawn; i++) {                        level[0].addNewEnemyOnTile(8, 8, startSpeed);                        break;                    }            }            setTimestamp();        }        Character mover = level[0].getMover();        for (int i = 0; i < enemy.size(); i++) {            enemy.get(i).movetotarget(mover);            if (enemy.get(i).movercheck(mover) && !isGameOver()) {                enemy.get(i).saySomething("Da haben wir dich!", true, 200);                setGameOver(true);                int dialogResult = JOptionPane.showConfirmDialog(gamePanel, "Dein Score beträgt " + enemy.size() + " innerhalb von " + elapsedTime(starttime) + " Sekunden \nOK : Neustart", "Game Over", JOptionPane.OK_CANCEL_OPTION);                if (dialogResult == JOptionPane.OK_OPTION) {                    respawn(0);                }            }        }    }    //////////////////////////////////////////////////////////////////////////////////    //////////////////////////////////////////////////////////////////////////////////    //////////////////////////////////////////////////////////////////////////////////    //<editor-fold desc="LEVEL 1">    ////LEVEL 1 - Intro = Das Attentat an den Präsidenten ////////////////////////////    //////////////////////////////////////////////////////////////////////////////////    //////////////////////////////////////////////////////////////////////////////////    public void createlevel1() {        //Laden der Maps:        Character mover = level[1].getMover();        level[1].setBaseMap("Content/Maps/Level 1 Base.txt", "Border");        level[1].getBaseMap().mapTiles[24][19].setBlocked(false);        level[1].getBaseMap().mapTiles[24][20].setBlocked(false);        level[1].setMap(2, "Content/Maps/Level 1 Items.txt", "null", new Point(0, 0));        // Intialisierung der Spieler:        mover.setLocation((7 * Tile.TILEWIDTH), 7 * Tile.TILEHEIGHT);        mover.setSpeed(15);        level[1].getEnemy(0).setLocation((4) * Tile.TILEWIDTH, (3) * Tile.TILEHEIGHT);        level[1].getEnemy(16).setLocation((5) * Tile.TILEWIDTH, (5) * Tile.TILEHEIGHT);        level[1].getEnemy(16).repeatedRightRun(10, 5, true);        createMarketSituation();        dialog = 1;        setCurrentLevel(1);    }    public void level1GameMechanic() {        level1Dialog();        if (dialog > 9 && dialog < 12) {            for (int i = 5; i < 7; i++) {                level[1].getEnemy(i).setSpeed(3);                level[1].getEnemy(i).movetotarget(0.75, level[1].getMover());            }            if (dialog < 12) {                level[1].getEnemy(0).repeatedRightRun(10, 5, true);            }        }        if (level[1].getMover().dangerCheck() && !isGameOver()) {            setGameOver(true);            int dialogResult = JOptionPane.showConfirmDialog(gamePanel, "Du wurdest erwischt\nJa : Neustart\nNein : zur Lobby ", "Game Over", JOptionPane.YES_NO_OPTION);            if (dialogResult == JOptionPane.YES_OPTION) {                respawn(1);            }            if (dialogResult == JOptionPane.NO_OPTION) {                respawn(0);            }        }    }    /**     * Erstellen von Map Chapter     * -> zur besseren Übersicht     * -> zum Neustarten von Maps     */    public void createMarketSituation() {        Random r = new Random();        for (int i = 1; i < 5; i++) {            level[1].getEnemy(i).setLocationAtTile(10 + r.nextInt(5), 13 + r.nextInt(1));        }        for (int i = 6; i < 10; i++) {            level[1].getEnemy(i).setLocationAtTile(10 + r.nextInt(1), 15 + r.nextInt(4));            level[1].getEnemy(i).setDirection(2);        }        for (int i = 11; i < 15; i++) {            level[1].getEnemy(i).setLocationAtTile(10 + r.nextInt(4), 20 + r.nextInt(1));            level[1].getEnemy(i).setDirection(3);        }    }    /**     * Dialog     * Reihenfolge des Gesprächs wird durch den int dialog angegeben     * dialog wird immer einen hochgezählt wenn die Bedingung (welche frei konfigurierbar ist) erfüllt wird     * BSP: dialog 2 - wird aufgerufen wenn dialog = 2 ist (bzw. der vorige Dialog ausgeführt wurde, der dialog auf 2 setzt)     *                 UND einmal geklickt wurde (Differenz aus momentanen Klickstand - alten Klickstand muss > oder = 1 ergeben)     *               - mithilfe von setSpeaking kann Dialog Bedingung erzwingt werden = Character kann sich nicht bewegen     * Weitere Bedingungen können bestimmte MoverPositionen / Schrittanzahl / Zeit sein     * => Nur wichtig, dass diese im Bedingungkopf stehen     */    public void level1Dialog() {        Character mover = level[1].mover;        int speakingspeed = 500;        if (dialog == 1) {            mover.saySomething("Was ist denn da los?" + "\n" + "(Klicken für weiteren Dialog)", true, speakingspeed);            mover.setSpeaking(true);            currentClick = click;            dialog = 2;        }//       //System.out.println("Click in Dialog 1 "+ click +"-"+ currentClick+"="+ (click - currentClick));        if (dialog == 2 && click - currentClick >= 1) {            mover.saySomething("W-A-S-D drücken um sich zu bewegen", true, speakingspeed);            mover.setSpeaking(false);            currentSteps = mover.getSteps();            dialog = 3;        }        if (dialog == 3 && mover.getSteps() - currentSteps >= 50) {            mover.saySomething("Super du kannst laufen !", true, speakingspeed);            setTimestamp();            dialog = 4;        }        if (dialog == 4 && elapsedTime(timestamp) > 2) {            mover.saySomething("Gehe zum Markt (markiertes Feld)", true, speakingspeed);            level[1].maps[0].mapTiles[16][15].setBorderInsets(new Insets(5, 5, 5, 5));            dialog = 5;        }        if (dialog == 5) {            level[1].getEnemy(0).enemystraightrun(new Point((int) level[1].getEnemy(0).getLocation().getX() / Tile.TILEWIDTH, 10), 0.5, 0, 1);        }        if (dialog == 5 && mover.isOnThisTile(16, 15, 4)) {            mover.saySomething("! Ich glaube da ist ein Unfall...", true, speakingspeed);            level[1].maps[0].mapTiles[16][15].setBorderInsets(new Insets(0, 0, 0, 0));            level[1].maps[0].mapTiles[13][16].setBorderInsets(new Insets(5, 5, 5, 5));            setTimestamp();            dialog = 6;        }        if (dialog == 6 && mover.isOnThisTile(13, 16, 4)) {            mover.saySomething("Ich muss helfen !!! Nichts wie hin", false, speakingspeed);            System.out.println("Automatisch zum verletzten laufen");            level[1].maps[0].mapTiles[11][19].setBorderInsets(new Insets(5, 5, 5, 5));            setTimestamp();            dialog = 7;        }        if (dialog == 7 && elapsedTime(timestamp) > 8) {            createlevel1();            mover.saySomething("Du warst zu langsam um zu helfen!", true, speakingspeed);            setTimestamp();            if (TimeUnit.MILLISECONDS.toSeconds(System.currentTimeMillis() - timestamp) > 4) {                dialog = 1;            }        }        if (dialog == 7 && mover.isOnThisTile(11, 19, 4)) {            mover.saySomething("Hallo ?! Ist alles okay, du siehts verletzt aus!", true, speakingspeed);            dialog = 8;        }        if (dialog == 8) {            level[1].getEnemy(2).saySomething("DU hast den Präsidenten verletzt !!! Haltet ihn auf !!", true, speakingspeed);            mover.saySomething("Ich wollte nur helfen.", true, speakingspeed);            setTimestamp();            dialog = 9;        }        if (dialog == 9 && elapsedTime(timestamp) > 4) {            level[1].getEnemy(3).saySomething("Holt ihn euch!!", true, speakingspeed);            dialog = 10;        }        if (dialog == 10) {            mover.saySomething("Ich muss schnell weg ! Ich bin UNSCHULDIG aber ich brauche Beweise", true, speakingspeed);            dialog = 11;        }        if (dialog == 11 && mover.isInThisArea(new Point(25, 19), new Point(26, 18), 4)) {            mover.speechBubble.setVisible(false);            mover.saySomething("Du hast es geschafft vom Fluchtort zu fliehen! Die K Fähigkeiten hast du schonmal um deine Unschuld zu beweisen! Intro ist vorzeitig beendet.\n Viel Spaß!", true, 50);            dialog = 12;        }    }    //////////////////////////////////////////////////////////////////////////////////    //////////////////////////////////////////////////////////////////////////////////    //////////////////////////////////////////////////////////////////////////////////    //</editor-fold>    //<editor-fold desc="LEVEL 2">    ////LEVEL 2 - First Chapter - "Das Entkommen aus Beach Town"   ////////////////////    //////////////////////////////////////////////////////////////////////////////////    //////////////////////////////////////////////////////////////////////////////////    public void createlevel2() {        /** Laden der Maps:         *         */        Character mover = level[2].getMover();        level[2].setBaseMap("Content/Maps/Level2 Concept", "All");        level[2].setMap(2, "Content/Maps/Level2 Concept", "All", new Point(0, 0));        //Immer auf BaseMap !! daher nicht im Map Konstruktor:        /** Intialisierung der Spieler:         *         */        mover.setLocation((5 * Tile.TILEWIDTH), 5 * Tile.TILEHEIGHT);        mover.setSpeed(15);        setCurrentLevel(2);    }    public void level2GameMechanic() {        /**         * Spielmechanik         */    }    public void level2Dialog() {        /**         * Dialog         */    }    //////////////////////////////////////////////////////////////////////////////////    //////////////////////////////////////////////////////////////////////////////////    //////////////////////////////////////////////////////////////////////////////////    //</editor-fold>    //<editor-fold desc="LEVEL 3">    ////LEVEL 3 - "XXXXXXX"  /////////////////////////////////////////////////////////    //////////////////////////////////////////////////////////////////////////////////    //////////////////////////////////////////////////////////////////////////////////    public void createlevel3() {        /** Laden der Maps:         *         */        Character mover = level[3].getMover();        level[3].setBaseMap("Content/Maps/XXXX", "All");        //Immer auf BaseMap !! daher nicht im Map Konstruktor://        level[3].initializeAnalytics();        /** Intialisierung der Spieler:         *         */        mover.setLocation((5 * Tile.TILEWIDTH), 5 * Tile.TILEHEIGHT);        mover.setSpeed(5);//        level[2].initializeAnalytics();        setCurrentLevel(3);    }    public void level3GameMechanic() {        /**         * Spielmechanik         */    }    public void level3Dialog() {        /**         * Dialog         */    }    //////////////////////////////////////////////////////////////////////////////////    //////////////////////////////////////////////////////////////////////////////////    //////////////////////////////////////////////////////////////////////////////////    //</editor-fold>    //<editor-fold desc="LEVEL 4">    ////LEVEL 4 - "XXXXXXX"  /////////////////////////////////////////////////////////    //////////////////////////////////////////////////////////////////////////////////    //////////////////////////////////////////////////////////////////////////////////    public void createlevel4() {        /** Laden der Maps:         *         */        Character mover = level[4].getMover();        level[4].setBaseMap("Content/Maps/XXXX", "All");        /** Intialisierung der Spieler:         *         */        mover.setLocation((5 * Tile.TILEWIDTH), 5 * Tile.TILEHEIGHT);        mover.setSpeed(5);        //        level[4].initializeAnalytics();        setCurrentLevel(4);    }    public void level4GameMechanic() {        /**         * Spielmechanik         */    }    public void level4Dialog() {        /**         * Dialog         */    }    //////////////////////////////////////////////////////////////////////////////////    //////////////////////////////////////////////////////////////////////////////////    //////////////////////////////////////////////////////////////////////////////////    //</editor-fold>    public void respawn(int level) {        switch (level) {            case 0:                createLobby();                break;            case 1:                createlevel1();                break;            case 2:                createlevel2();                break;            case 3:                createlevel3();                break;            case 4:                createlevel4();                break;        }        gameOver = false;    }    public void renderLevel(Graphics2D g2d) {        level[currentLevel].renderLevel(g2d);//        try {//            level[currentLevel].getEnemys()[2].drawWalkingStripes(g2d,level[currentLevel].maps[0].mapTiles[2][2],level[currentLevel].maps[0].mapTiles[5][2]);//        } catch (Exception e) {//            System.out.println("NP - Enemy besteht noch nicht !");//        }    }    /**     * Allgemeine Spiel update Methode, die im Thread aufgerufen werden muss, damit das Spiel funktioniert !     */    public void updateLevel() {        level[currentLevel].update();        switch (currentLevel) {            case 0:                level0GameMechanic();                break;            case 1:                level1GameMechanic();                break;            case 2:                level2GameMechanic();                break;            case 3:                level3GameMechanic();                break;            case 4:                level4GameMechanic();                break;        }        //DEBUGGING THINGS        try {            levelAnzeige.setText("Game: " + currentLevel + "\n"//                    + "\n" + "Steps:" + mover.getSteps()                    + "\n" + "X- Offset:" + gamePanel.getCamera().getXOffset() + "\n" + "Y- Offset:" + gamePanel.getCamera().getYOffset()                    + "\n" + "Camera Size:" + gamePanel.getCamera().getxSize() + "\n" + gamePanel.getCamera().getySize()                    + "\n" + "KeyInput:" + GUI.keyInputToMove(keyListener).getLocation());        } catch (Exception e) {        }    }    /**     * Löschen aller Level Instanzen     */    public void clear() {        //remove all Level Components        active = false;    }    /**     * set Methoden (Einstellen des Levels,Einstellen der GridLines)     */    public void setCurrentLevel(int currentLevel) {        dialog = 1;        this.currentLevel = currentLevel;    }    public void setGridLines() {        for (int i = 0; i < level.length; i++) {            if (level[i].isGridlines()) {                level[i].setGridLines(false);            } else {                level[i].setGridLines(true);            }        }    }    //    public JPanel createInfoPane(){//        InfoTextArea info = new InfoTextArea("");//        info.appendHeading("Info");//        info.appendRegularText//                (" Willkommen zu Chase ME! Du willst wissen was das Spiel kann? " +//                        " Zur Entstehung und Spielidee" +//                        " Du bist ein gejagter Mann, dem ein Verbrechen untergejubelt wurde" +//                        " Dein bester Freund ist ein Hacker und konnte dadurch die richtigen" +//                        " Verbrecher finden." +//                        " Daher musst du um deine Unschuld zu Beweisen aus BeachTown entkommen und in" +//                        " Castle City die echten Verbrecher finden." +//                        " Das Spiel besteht aus insgesamt 5 verschiedenen Level die jeweils in eigene Kapitel eingeteilt sind" +//                        " Wenn du schaffst alle Rätsel zu lösen erwarest du ein Geschenk!" +//                        " Außerdem kannst du auch deine eigenen Maps erstellen (im Editor Tab) und mithilfe " +//                        " der Level Klasse, ein eigenes Level realisieren. Der Quellcode ist sehr detailreich beschrieben" +//                        " ,sodass ein Level kinderleicht zu erstellen ist. " +//                        " Achtung: Bearbeiten von unerlaubtem Code kann" +//                        " zu Problemen führen, weshalb diese nur unter Vorsicht bearbeitet werden sollten! " +//                        " Steuerung:"+//                        " W: Oben Laufen  S: Unten Laufen" +//                        " A: Links Laufen D: Rechts Laufen" +//                        " Viel Spaß beim Rätseln  -Kevin");//       return info;//    }    public JPanel createInfoPane() {        InfoTextArea editorInfoPane = new InfoTextArea("");        editorInfoPane.appendHeading("ChaseMe Info");        editorInfoPane.appendRegularText                ("Willkommen zum Editor ! Du willst wissen was der Editor kann? " +                        "\n Es können ganz einfach Maps erstellt werden" +                        "\n Es gibt ein eigenes Menü für den Editor, dazu einfach" +                        "\n auf das Menü (unten in der Leiste) -> Editor -> Tile Menü" +                        "\n Du kannst deine gewünschten Tiles mit Doppelklick direkt anwählen oder durch einen Klick und und per Bestätigen." +                        "\n Um die TIle zu verändern einfach auf die gewünschte Fläche in deiner Map klicken ." +                        "\n Mit der Shift Taste und zwei Klicks können ganze Flächen ausgewählt und geändernt werden" +                        "\n Mit der STR Taste können Tiles aus der Map ganz einfach kopiert und verwendet werden." +                        "\n Kamera - Steuerung:" +                        "\n W: Kamera nach oben bewegen" +                        "\n A: Kamera nach links bewegen" +                        "\n S: Kamera nach unten bewegen" +                        "\n D: Kamera nach rechts bewegen" +                        "\n - : Zoom verringern | + : Zoom erhöhen" +                        "\n ..." +                        "\n Viel Spaß beim Maps bauen \n -Kevin");        return editorInfoPane;    }    /**     * Funktionsmethoden (momentanes Level,ob das Spiel läuft,ob GridLines fürs Debuggen angezeigt werden sollen)     */    public void setTimestamp() {        timestamp = System.currentTimeMillis();    }    public long elapsedTime(long timestamp) {        return TimeUnit.MILLISECONDS.toSeconds(System.currentTimeMillis() - timestamp);    }    public boolean isGridLines() {        return gridLines;    }    public boolean isActive() {        return active;    }    public int whichLevel() {        return currentLevel;    }    public boolean isGameOver() {        return gameOver;    }    public void setGameOver(boolean gameOver) {        if (gameOver) {            level[currentLevel].stop();        }        this.gameOver = gameOver;    }    /**     * Listener Methoden - werden vom jeweiligen Listener aufgerufen     */    /**     * ActionListener - wenn Button geklickt wird mit Zahlen = Erstellen des jeweiligen Levels     * -> kann einfach in     */    public void actionPerformed(ActionEvent e) {        JButton temp = (JButton) e.getSource();        try {            switch (Integer.parseInt(temp.getText())) {                case 1:                    createlevel1();                    break;                case 2:                    createlevel2();                    break;                case 3:                    createlevel3();                    break;                case 4:                    createlevel4();                    break;            }        } catch (NumberFormatException ex) {            switch (temp.getText()) {                case "Lobby":                    createLobby();                    break;            }            System.out.println("Button without Number was pressed in Game(Listener)");        }    }    /**     * MouseListener - wenn geklickt wird = click Variable (zum Klicks zählen) hochgezählt     */    public void mouseClicked(MouseEvent e) {        click++;    }}